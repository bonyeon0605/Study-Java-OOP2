# 자바의 정석 스터디
> ### 7장 객체지향 프로그래밍2
1.1 상속의 정의와 장점   
상속 - 기존 클래스를 재사용하여 새로운 클래스를 작성, 재사용성 높다, 중복을 제거하여 생산성과 유지보수에 기여   
<pre><code>class Child extends Parents {
    //....
}</code></pre>    
- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
- 부모 자식의 관계만 존재(상속관계)
- 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성

1.2 클래스간의 관계 - 포함관계
- 상속이외에도 클래스를 재사용하는 또 다른 방법
- 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것
<pre><code>class Car {
    Engine e = new Engine(); // 엔진
    Door[] d = new Door[4];  //  문. 문의 갯수를 넷으로 가정하고 배열로 처리
}</code></pre>   

1.3 클래스간의 관계 결정하기   
> **상속관계** '~은 ~이다.' (is - a)   
> **포함관계** '~은 ~을 가지고 있다.' (has - a)

1.4 단일 상속
- 장점 - 클래스 간의 관계가 보다 명확. 코드를 더욱 신뢰   

1.5 Object 클래스 - 모든 클래스의 조상   

2.1 오버라이딩 - 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것    

2.2 오버라이딩 조건
> - 이름이 같아야 한다.
> - 매개변수가 같아야 한다.
> - 반환타입이 같아야 한다.

> 조상 클래스의 메서드를 자손 클래스에서 오버라이딩 할 때
> 1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
> 2. 예외는 조상 클래스의 메서드보다 많이 선언 할 수 없다.
> 3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경 할 수 없다.

2.3 오버로딩 VS 오버라이딩   
> **오버로딩(overloading)** - 기존에 없는 새로운 메서드를 정의하는 것(new)   
> **오버라이딩(overriding)** - 상속받은 메서드의 내용을 변경하는 것이 좋다(change, modify)    

2.4 super - 상속받은 멤버를 참조하는데 사용되는 참조 변수    
* 조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고는 super와 this는 근본적으로 같다.
* super와 this는 인스턴스 메서드에서만 사용 가능    

2.5 super() - 조상 클래스의 생성자      

4.1 제어자 - 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여   

4.2 static - 클래스의, 공통적인   
> **static 이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭**
> * 인스턴스를 생성하지 않고도 호출이 가능해서 더 편리하고 속도도 더 빠름   

4.3 final - 마지막의, 변경될 수 없는   
> **final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수** 
> * 클래스 - 변경될 수 없는 클래스, 다른 클래스의 조상이 될 수 없다.
> * 메서드 - 오버라이딩 불가
> * 변수 - 값을 변경할 수 없는 상수

4.4 abstract - 추상의, 미완의
> **abstract가 사용 될 수 있는 곳 - 클래스, 메서드**
> * 클래스 - 클래스 내에 추상 메서드가 선언되어 있음을 의미
> * 메서드 - 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드   

4.5 접근제어자   
>* private - 같은 클래스 내에서만 접근이 가능
>* default - 같은 패키지 내에서만 접근이 가능
>* protected - 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능
>* public - 접근 제한이 없다.   
>* public > protected > (default) > private   

>**접근 제어자를 사용하는 이유**
> * 외부로부터 데이터를 보호하기 위해서
> * 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서  

5.1 다형성이란 - 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함
* **조상 클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 함**
* 여러가지 형태를 가질 수 있는 능력   
* 조상타입의 참조변수로 자손타입의 인스턴스를 참조 할 수 있다.
* 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.   
> 참조변수는 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 갯수를 조절하는 것뿐...

5.3 instanceof 연산자 - 인스턴스의 실제 타입 확
> 어떤 타입에 대한 instanceof 연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것 

5.4 참조변수와 인스턴스의 연결   
* 메서드는 참조변수의 타입에 관계없이 항상 실제 인스턴스의 타입인 자손클래스에 정의 메서드가 호출되지만, 변수는 참조변수의 타입에 따라서 달라진다.   

6.1 추상클래스란 - 미완성 설계도, 추상메서드(미완성 메서드)를 포함   
6.2 추상메서드 - 선언부만 작성, 상속받은 자손 클래스가 상황메 맞게 적절하게 구성, 추상 메서드에 abstract를 붙여 선언하는 이유는 강요하기 위해서...   

7.1 인터페이스란
>일종의 추상클래스. 추상화 정도가 높아서 멤버변수와 일반 메서드를 가질 수 없다.    
>오직 추상메서드와 상수만 멤버로 가질 수 있다.   
>'기본설계도'

7.2 인터페이스 작성
<pre><code>interface 인터페이스이름 {
    public static final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수목록);
}</code></pre>
>* 모든 멤버변수는 public static final 이어야 하며, 이를 생략 가능
>* 모든 메서드는 pubic abstract 이어야 하며, 이를 생략 가능
> (단, static메서드와 디폴트 메서드는 제외)

7.3 인터페이스 다중상속 가능

7.4 인터페이스의 구현 - implements를 사용






